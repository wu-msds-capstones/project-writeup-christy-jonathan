# Results

##### Research and Identification of Core Strategies


Using the analysis of the strategy-tagged features above, we moved forward with the following set of indicators to analyze:

independent variables = `new_listings`, `inventory`, `num_housing_units`,
`median_income`, `population`, `property_tax`, `homes_sold`, `days_on_market`

dependent variable = `median_sale_price`

**Scatter Plot Samples**

What we found early on in the analysis was that there is a big difference in how features respond to `median_sale_prices`
depending on the county density.  For example, the following scatter plot clusters are from Washington and Wheeler Counties.
This is a trend that will show up all through the analysis.

:::{#fig-scatter layout-ncol=2}
![Washington County Scatterplots (Click to View)](images/washington_scatter.png){#wash-scatter width=300}

![Wheeler County Scatterplots (Click to View)](images/wheeler_scatter.png){#wheeler-scatter width=300}
:::


**Trend Plots and MK numbers**

Trend analysis for time series is interesting to plot.  We found out a lot about this data by plotting this data over time.  You can see in the 
trends below that the densely populated counties (top 2 graphs) are trend in a similar manner, but differ from the sparsely populated counties
(bottom 2 graphs).

![Home Sale Price Trend in Densely Populated vs Sparsely Populated Oregon Counties](images/county_sales.png){#fig-county-sales}

Trends can also show us where housing payments began to become unaffordable, like in the figure below.

```{python}
#| label: fig-mortgage-affordability
#| fig-cap: "<br>Median Mortgage Principal and Interest Payments vs Maximum Affordable Housing Price"

import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots

# Load the dataset
file_path = 'housing_engineered.csv'
housing_data_engineered = pd.read_csv(file_path)

# Convert the date column to datetime format
housing_data_engineered['date'] = pd.to_datetime(housing_data_engineered['date'])
housing_data_engineered['county'] = housing_data_engineered['county'].apply(lambda x: x.capitalize())

# Get unique list of counties
counties = housing_data_engineered['county'].unique()

# Create initial figure
fig = make_subplots()

# Add traces for the initial county (first county in the list)
initial_county_data = housing_data_engineered[housing_data_engineered['county'] == counties[0]]
fig.add_trace(go.Scatter(x=initial_county_data['date'], y=initial_county_data['monthly_housing_payment'], mode='lines', name='Monthly Median Mortgage P&I Payment', line_color='#1f77b4'))
fig.add_trace(go.Scatter(x=initial_county_data['date'], y=initial_county_data['monthly_affordable_housing_payment'], mode='lines', name='Monthly Affordable Housing Payment', line_color='#ff7f0e'))

# Update plot sizing
fig.update_layout(
    template="plotly_white",
)

# Update layout with dropdown
dropdown_buttons = [
    {
        'args': [{'y': [housing_data_engineered[housing_data_engineered['county'] == county]['monthly_housing_payment'],
                        housing_data_engineered[housing_data_engineered['county'] == county]['monthly_affordable_housing_payment']],
                 'x': [housing_data_engineered[housing_data_engineered['county'] == county]['date'],
                       housing_data_engineered[housing_data_engineered['county'] == county]['date']],
                 'type': 'scatter'}],
        'label': county,
        'method': 'update'
    }
    for county in counties
]


layout = dict(
   buttons = dropdown_buttons,
   direction =  'down',
   showactive = True,
   pad={"r": 10},
   yanchor="top",
   y=0.95,
   xanchor="left",
   x=1.05
)

fig.update_layout(margin=dict(t=100, b=50)) 

fig.update_layout(legend=dict(
    yanchor="top",
    y=1.05,
    xanchor="left",
    x=-.07,

))

fig.update_layout(
    updatemenus=[
        layout
    ]
)

# Add annotation for the dropdown
fig.add_annotation(
    text="County",
    x=1.15,  # X position of the annotation
    y=1.0,   # Y position of the annotation (adjusted to be slightly above the dropdown)
    xref="paper",  # Reference to the paper coordinate system
    yref="paper",
    showarrow=False,  # No arrow
    font=dict(size=12)  # Font size
)

# Update axis labels and title
fig.update_layout(
    title='Oregon Housing Is Unaffordable<br><sup>Oregon 30-Year Mortgage Principal and Interest Payments Are Outpacing Affordability</sup>',
    xaxis_title='Date',
    yaxis_title='Monthly Mortgage Payment<br>Monthly Affordable Housing Payment <br> (Inflation Adjusted U.S. Dollars)',
)
fig.update_layout(yaxis_tickprefix = '$')
fig.update_traces(mode="lines", hovertemplate=None)
fig.update_layout(hovermode="x")
fig.update_layout(hoverlabel_namelength=-1)

# Show the plot
fig.show()
```

**Homes Sold Feature Significance**

After the home sold feature significance study, we narrowed the features to:

| feature             | percent of home sales represented |
|---------------------|-----------------------------------|
| `inventory`         | 99.91256033101263                 |
| `num_housing_units` | 99.984587972013                   |
| `median_income`     | 99.984587972013                   |
| `population`        | 99.1469914305979                  |
| `property_tax`      | 99.984587972013                   |
| `days_on_market`    | 99.81316847705574                 |


**Linear Regression - linear plot samples for populated and unpopulated counties**

Washington County Results - heavily populated county

* Independent Variable Combination: ['num_housing_units', 'days_on_market', 'inventory']
* Evaluation Statistics: R^2: 0.9550268107703429, MAE: 18.991051374287636, RMSE: 24.584835761694823
* Anderson-Darling test for residuals: below 0.05 generally means non-normal: 0.060124359532653535
* Coefficients: 
  + `num_housing_units` = 84.85562076, 
  + `days_on_market` = -8.46017593, 
  + `inventory` = -1.06431453

This coefficient for `num_housing_units` a strong indicator that if you increase housing units, median house prices will rise.
This is surprising given that a lot of the focus is on building more housing at a faster pace.

Wheeler County Results - sparsely populated county

* Independent Variable Combination: ['num_housing_units', 'days_on_market', 'inventory']
* Evaluation Statistics: R^2: 0.02140717912691359, MAE: 134.56532825628832, RMSE: 185.9532651361748
* Anderson-Darling test for residuals: below 0.05 generally means non-normal: 2.099955001334869e-12
* Coefficients: 
  + `num_housing_units` = 18.18540814, 
  + `days_on_market`= 30.85635937, 
  + `inventory` = -29.20292623

Findings:

1.  Regression fits well to densely populated counties with a median sale price target.
2.  Sparsely populated counties are best modeled by collected data to median sale prices.


**Random Forest Model - Feature importances, decision tree, table of results** 


![Significant Feature Count in Oregon Counties](images/sig_feature_county_count.png){#fig-sig-feature-count-rf}

![Significant Feature Representation in Percentage of Homes Sold in Oregon](images/sig_feature_county_represent.png){#fig-sig-feature-representation-rf}


Random Forest Feature Importance:

![Random Forest Feature Importance](images/random_forest_permutation_importance.png){#fig-rf-feature-imp}

Resultant Forest Decsion Tree:

![Random Forest Decision Tree](images/random_forest-tree.png){#fig-rf-decision-tree}


```{python}
#| label: tbl-ohe_example
#| tbl-cap: 'One-hot vectorization example'
#| tbl-column: body
#| tbl-pos: H

import pandas as pd
import numpy as np

weather_df = pd.DataFrame(np.random.rand(10,2)*5,
                          index=pd.date_range(start="2021-01-01", periods=10),
                          columns=["Tokyo", "Beijing"])

def rain_condition(v):
    if v < 1.75:
        return "Dry"
    elif v < 2.75:
        return "Rain"
    return "Heavy Rain"

def make_pretty(styler):
    styler.set_caption("Weather Conditions")
    styler.format(rain_condition)
    styler.format_index(lambda v: v.strftime("%A"))
    styler.background_gradient(axis=None, vmin=1, vmax=5, cmap="YlGnBu")
    return styler

weather_df
```

Testing python output
